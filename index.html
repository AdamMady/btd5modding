<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BTD5 LIVE Editor</title>
  <style>
    /* Minimal reset */
    * {
      margin: 0; 
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
      background: #f5f5f5;
      color: #333;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header bar */
    #topBar {
      display: flex;
      align-items: center;
      background: #333;
      color: #fff;
      padding: 0.5em;
    }
    #selectFolderBtn {
      background: #4caf50;
      border: none;
      color: #fff;
      padding: 0.6em 1.2em;
      font-size: 1em;
      cursor: pointer;
      border-radius: 4px;
      margin-right: 1em;
    }
    #selectFolderBtn:hover {
      background: #45a049;
    }
    #statusMsg {
      font-size: 0.9em;
      color: #ccc;
      margin-right: auto; /* push the resetAllBtn to the right */
      margin-left: 0.5em;
    }
    #resetAllBtn {
      background: #ff5c5c;
      border: none;
      color: #fff;
      padding: 0.6em 1.2em;
      font-size: 1em;
      cursor: pointer;
      border-radius: 4px;
      margin-left: 1em;
    }
    #resetAllBtn:hover {
      background: #e54848;
    }

    /* Main container: left (folder tree) + right (editor) */
    #container {
      flex: 1;
      display: flex;
      height: calc(100vh - 50px);
    }

    /* Left panel: folder tree & search bar */
    #folderListPanel {
      background: #fff;
      border-right: 1px solid #ccc;
      padding: 0.75em;
      resize: horizontal;
      overflow: auto;
      width: 300px; 
      min-width: 150px;
      max-width: 800px;
      display: flex;
      flex-direction: column;
    }
    #searchInput {
      margin-bottom: 0.5em;
      padding: 0.4em;
      width: 100%;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    /* Right panel: editor */
    #editorPanel {
      flex: 1;
      padding: 0.75em;
      overflow-y: auto;
    }

    /* Folder / file listings */
    #folderTree {
      flex: 1;
      overflow-y: auto;
    }
    .folderItem, .fileItem {
      display: flex;
      align-items: center;
      cursor: pointer;
      margin: 0.2em 0;
      padding: 0.2em 0;
    }
    .folderItem:hover, .fileItem:hover {
      background: #eee;
    }
    .folderIcon, .fileIcon {
      margin-right: 0.4em;
    }
    .folderItem b {
      font-weight: bold;
    }

    /* Editor styling */
    h2 {
      margin-bottom: 0.5em;
      font-size: 1.2em;
    }
    .editorTable {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5em;
      background: #fff;
    }
    .editorTable thead th {
      background: #f0f0f0;
      text-align: left;
      padding: 0.4em;
      border-bottom: 1px solid #ccc;
      font-weight: normal;
    }
    .editorTable tbody td {
      border-bottom: 1px solid #eee;
      padding: 0.4em;
      vertical-align: middle;
    }
    .editorTable input[type="text"] {
      width: 80%;
      padding: 0.2em;
    }
    .revertBtn {
      margin-left: 0.5em;
      cursor: pointer;
      background: none;
      border: none;
      font-size: 1.1em;
      color: #666;
    }
    .revertBtn:hover {
      color: #111;
    }

    /* Scrolling fix on smaller screens */
    @media (max-width: 768px) {
      #container {
        flex-direction: column;
      }
      #folderListPanel {
        width: 100%;
        height: 250px;
        resize: none; /* On mobile, can't easily drag */
      }
      #editorPanel {
        height: calc(100vh - 300px);
      }
    }
  </style>
</head>
<body>
  <!-- Top bar -->
  <div id="topBar">
    <button id="selectFolderBtn">Select Folder</button>
    <span id="statusMsg">No folder selected</span>
    <button id="resetAllBtn" class="hidden">Reset All to Default</button>
  </div>

  <!-- Main container -->
  <div id="container">
    <!-- Left side: folder list + search -->
    <div id="folderListPanel">
      <input type="text" id="searchInput" placeholder="Search files..." />
      <h2>Folder View</h2>
      <div id="folderTree"></div>
    </div>

    <!-- Right side: editor -->
    <div id="editorPanel">
      <h2 id="editorTitle">No file selected</h2>
      <div id="editorContent"></div>
    </div>
  </div>

<script>
/**************************************************************
 * We'll rely on the File System Access API in Chromium-based
 * browsers on HTTPS/localhost.
 **************************************************************/
let rootDirectoryHandle = null;
let folderStructure = null; // pruned structure with only .weapon/.upgrades
let originalStructure = null; // unfiltered copy for search

// Keep track of each file's data: { fileHandle -> { jsonData, originalJson, numericFields[] } }
let editableFilesMap = new Map();
// Currently displayed file
let currentFileHandle = null;

/**************************************************************
 * DETECT .weapon/.upgrades
 **************************************************************/
function isEditableFile(name) {
  const lower = name.toLowerCase();
  return lower.endsWith(".weapon") || lower.endsWith(".upgrades");
}
function removeExtension(fileName) {
  // remove .weapon or .upgrades
  return fileName.replace(/(\.weapon|\.upgrades)$/i, "");
}

/**************************************************************
 * Build a pruned folder structure
 **************************************************************/
async function buildFolderStructure(dirHandle) {
  const subFolders = {};
  const files = {};

  for await (const [name, handle] of dirHandle.entries()) {
    if (handle.kind === "directory") {
      const child = await buildFolderStructure(handle);
      if (child) {
        subFolders[name] = child;
        subFolders[name].handle = handle;
      }
    } else {
      if (isEditableFile(name)) {
        files[name] = handle;
      }
    }
  }

  const hasContent = (Object.keys(subFolders).length > 0) || (Object.keys(files).length > 0);
  if (!hasContent) return null;
  return { subFolders, files, handle: dirHandle };
}

/**************************************************************
 * RENDER FOLDER TREE
 **************************************************************/
function renderFolderTree(structure, container, level=0) {
  if (!structure) return;

  // subFolders
  for (const folderName in structure.subFolders) {
    const folderNode = structure.subFolders[folderName];

    const folderDiv = document.createElement("div");
    folderDiv.className = "folderItem";
    folderDiv.style.marginLeft = (level * 1.2) + "em";

    const folderIcon = document.createElement("span");
    folderIcon.className = "folderIcon";
    folderIcon.textContent = "ðŸ“";
    folderDiv.appendChild(folderIcon);

    const folderLabel = document.createElement("b");
    folderLabel.textContent = folderName;
    folderDiv.appendChild(folderLabel);

    container.appendChild(folderDiv);
    renderFolderTree(folderNode, container, level + 1);
  }

  // files
  for (const fileName in structure.files) {
    const fileHandle = structure.files[fileName];
    const displayName = removeExtension(fileName);

    const fileDiv = document.createElement("div");
    fileDiv.className = "fileItem";
    fileDiv.style.marginLeft = (level * 1.2 + 1) + "em";

    const fileIcon = document.createElement("span");
    fileIcon.className = "fileIcon";
    fileIcon.textContent = "âš™ï¸";
    fileDiv.appendChild(fileIcon);

    const fileLabel = document.createElement("span");
    fileLabel.textContent = displayName;
    fileDiv.appendChild(fileLabel);

    fileDiv.onclick = async () => {
      showEditorForFile(fileHandle, fileName, displayName);
    };

    container.appendChild(fileDiv);
  }
}

/**************************************************************
 * LOAD & SAVE JSON
 * 
 * To detect float vs integer, we do a raw-text pass for each numeric field
 * *before* we parse. If we see a decimal point in the raw text, we mark it float.
 **************************************************************/
async function readJson(fileHandle) {
  const fileData = await fileHandle.getFile();
  const text = await fileData.text();
  let parsed = {};
  try {
    parsed = JSON.parse(text);
  } catch (err) {
    console.error("JSON parse error:", fileHandle.name, err);
  }
  return { rawText: text, parsed };
}

async function writeJson(fileHandle, jsonObj) {
  try {
    const writable = await fileHandle.createWritable();
    await writable.write(JSON.stringify(jsonObj, null, 2));
    await writable.close();
  } catch (err) {
    console.error("Error writing file:", fileHandle.name, err);
  }
}

/**************************************************************
 * DETECT NUMERIC FIELDS
 **************************************************************/
function collectNumericFields(jsonObj, parentPath="", rawText) {
  // We'll return an array of { path, value, originalIsFloat }
  // We'll detect originalIsFloat by scanning rawText if possible.
  const result = [];
  for (let key in jsonObj) {
    if (!jsonObj.hasOwnProperty(key)) continue;
    const val = jsonObj[key];
    const fullPath = parentPath ? parentPath + "." + key : key;

    if (val && typeof val === "object") {
      result.push(...collectNumericFields(val, fullPath, rawText));
    } else if (typeof val === "number") {
      // detect float by searching rawText for the substring
      const maybeFloat = checkIfOriginallyFloat(fullPath, val, rawText);
      result.push({
        path: fullPath,
        value: val,
        originalIsFloat: maybeFloat
      });
    }
  }
  return result;
}

/**
 * Heuristic to see if original JSON had a decimal:
 * - We search for the pattern: "<key>" : [someNumber], ignoring spaces
 * - If we find that someNumber has a '.', we consider it float
 * - If the number is negative or includes exponent, handle that too if needed
 */
function checkIfOriginallyFloat(path, val, rawText) {
  // We'll try a rough approach:
  // 1) Extract the last part of path => the key
  const lastDotIndex = path.lastIndexOf(".");
  const keyName = lastDotIndex === -1 ? path : path.substring(lastDotIndex + 1);

  // 2) Build a rough pattern: "keyName": maybe with quotes
  //    We'll remove quotes from keyName if any
  //    Then we try a regex that finds "keyName"\s*:\s*([\-\d\.eE]+)
  //    and checks if that group has a decimal point.
  const regexKey = keyName.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"); // escape
  const re = new RegExp(`["']${regexKey}["']\\s*:\\s*([\\-\\+]?\\d+(\\.\\d+)?([eE][\\-\\+]?\\d+)?)(\\s|,|}|])`);

  // We'll remove newlines/spaces for easier matching, or we can just keep them
  // but the pattern tries to handle spacing with \\s* anyway
  // Let's just do a normal match:
  const match = re.exec(rawText);
  if (!match) {
    // not found => fallback
    // if val is integer => false
    // else => true
    return !Number.isInteger(val);
  }
  // match[1] is the numeric substring
  const numericStr = match[1];
  // If it has '.', we consider it float
  if (numericStr.includes(".")) {
    return true;
  }
  return false;
}

/**************************************************************
 * SHOW EDITOR
 **************************************************************/
async function showEditorForFile(fileHandle, realFileName, displayName) {
  currentFileHandle = fileHandle;

  const titleEl = document.getElementById("editorTitle");
  titleEl.textContent = displayName;

  const container = document.getElementById("editorContent");
  container.innerHTML = "<p>Loading...</p>";

  // Check map
  let stored = editableFilesMap.get(fileHandle);
  if (!stored) {
    // read from disk
    const { rawText, parsed } = await readJson(fileHandle);
    const originalJson = JSON.parse(JSON.stringify(parsed));
    // Gather numeric fields with float detection
    const numericFields = collectNumericFields(parsed, "", rawText);

    stored = {
      jsonData: parsed,
      originalJson,
      numericFields
    };
    editableFilesMap.set(fileHandle, stored);
  }

  // Now build a table for numeric fields
  const { jsonData, originalJson, numericFields } = stored;
  container.innerHTML = "";

  if (numericFields.length === 0) {
    container.innerHTML = "<p>No numeric fields found in this file.</p>";
    return;
  }

  const table = document.createElement("table");
  table.className = "editorTable";

  const thead = document.createElement("thead");
  const trHead = document.createElement("tr");
  const thPath = document.createElement("th");
  thPath.textContent = "Path";
  const thVal = document.createElement("th");
  thVal.textContent = "Value";
  trHead.appendChild(thPath);
  trHead.appendChild(thVal);
  thead.appendChild(trHead);

  const tbody = document.createElement("tbody");
  numericFields.forEach((field) => {
    const tr = document.createElement("tr");

    const tdPath = document.createElement("td");
    tdPath.textContent = field.path;
    tr.appendChild(tdPath);

    const tdVal = document.createElement("td");

    // We decide how to show the initial text:
    // If originalIsFloat, but current value is integer => show e.g. "3.0"
    const initialStr = formatDisplay(field.value, field.originalIsFloat);
    const input = document.createElement("input");
    input.type = "text";
    input.value = initialStr;

    input.onchange = async () => {
      // parse user input
      const newVal = parseUserNumber(field.value, input.value, field.originalIsFloat);
      field.value = newVal;
      setNestedValue(jsonData, field.path, newVal);

      // Force the text box to reflect the â€œ.0â€ if needed
      const forcedStr = formatDisplay(newVal, field.originalIsFloat);
      input.value = forcedStr;

      // Write to disk
      await writeJson(fileHandle, jsonData);
    };

    tdVal.appendChild(input);

    // Revert button
    const revertBtn = document.createElement("button");
    revertBtn.className = "revertBtn";
    revertBtn.textContent = "ðŸ”„";
    revertBtn.title = "Revert to default";
    revertBtn.onclick = async () => {
      // revert field in memory
      const origVal = getNestedValue(originalJson, field.path);
      field.value = origVal;
      setNestedValue(jsonData, field.path, origVal);

      input.value = formatDisplay(origVal, field.originalIsFloat);

      await writeJson(fileHandle, jsonData);
    };
    tdVal.appendChild(revertBtn);

    tr.appendChild(tdVal);
    tbody.appendChild(tr);
  });

  table.appendChild(thead);
  table.appendChild(tbody);
  container.appendChild(table);
}

/**************************************************************
 * INT/FLOAT FORMAT
 * If originalIsFloat == true and user typed integer, show .0
 **************************************************************/
function parseUserNumber(oldVal, newStr, originalIsFloat) {
  const parsed = Number(newStr);
  if (isNaN(parsed)) {
    return oldVal; // revert
  }
  if (originalIsFloat) {
    // If user typed integer, e.g. 3 => 3.0
    if (Number.isInteger(parsed)) {
      return parseFloat(parsed.toFixed(1));
    }
    return parsed;
  } else {
    // It's originally an integer => no decimals
    return Math.trunc(parsed);
  }
}

/** Format for display in the text box */
function formatDisplay(numVal, isFloat) {
  if (isFloat) {
    // If integer, add .0
    if (Number.isInteger(numVal)) {
      return numVal.toFixed(1); // e.g. 3 => "3.0"
    }
    return String(numVal);
  } else {
    // integer
    return String(Math.trunc(numVal));
  }
}

/**************************************************************
 * GET/SET NESTED
 **************************************************************/
function getNestedValue(obj, path) {
  const parts = path.split(".");
  let cur = obj;
  for (let p of parts) {
    if (!cur || typeof cur !== "object") return undefined;
    cur = cur[p];
  }
  return cur;
}
function setNestedValue(obj, path, val) {
  const parts = path.split(".");
  const last = parts.pop();
  let cur = obj;
  for (let p of parts) {
    if (typeof cur[p] !== "object") {
      cur[p] = {};
    }
    cur = cur[p];
  }
  cur[last] = val;
}

/**************************************************************
 * RESET ALL
 **************************************************************/
async function resetAllToDefault() {
  for (const [fileHandle, dataObj] of editableFilesMap.entries()) {
    // revert entire json
    dataObj.jsonData = JSON.parse(JSON.stringify(dataObj.originalJson));
    // also revert numericFields
    dataObj.numericFields.forEach((field) => {
      const origVal = getNestedValue(dataObj.originalJson, field.path);
      field.value = origVal;
    });
    // write
    await writeJson(fileHandle, dataObj.jsonData);
  }
  // Refresh if current file is open
  if (currentFileHandle) {
    const stored = editableFilesMap.get(currentFileHandle);
    if (stored) {
      showEditorForFile(currentFileHandle, currentFileHandle.name, "");
    }
  }
  alert("All editable files have been reset to default.");
}

/**************************************************************
 * SEARCH
 **************************************************************/
function filterStructure(structure, searchTerm) {
  if (!structure) return null;
  const subFolders = {};
  const files = {};
  searchTerm = searchTerm.toLowerCase();

  for (const folderName in structure.subFolders) {
    const child = filterStructure(structure.subFolders[folderName], searchTerm);
    if (child) {
      subFolders[folderName] = child;
    }
  }
  for (const fileName in structure.files) {
    const displayName = removeExtension(fileName).toLowerCase();
    if (displayName.includes(searchTerm)) {
      files[fileName] = structure.files[fileName];
    }
  }
  const hasContent = (Object.keys(subFolders).length > 0) || (Object.keys(files).length > 0);
  if (!hasContent && searchTerm) {
    return null;
  }
  return { subFolders, files, handle: structure.handle };
}

function onSearchChange(searchTerm) {
  const container = document.getElementById("folderTree");
  container.innerHTML = "";
  if (!originalStructure) return;
  if (!searchTerm.trim()) {
    // show full
    renderFolderTree(originalStructure, container);
  } else {
    const filtered = filterStructure(originalStructure, searchTerm);
    if (!filtered) {
      container.innerHTML = "<p>No results found.</p>";
    } else {
      renderFolderTree(filtered, container);
    }
  }
}

/**************************************************************
 * MAIN
 **************************************************************/
document.addEventListener("DOMContentLoaded", () => {
  const selectFolderBtn = document.getElementById("selectFolderBtn");
  const statusMsg = document.getElementById("statusMsg");
  const folderTreeContainer = document.getElementById("folderTree");
  const resetAllBtn = document.getElementById("resetAllBtn");
  const searchInput = document.getElementById("searchInput");

  selectFolderBtn.addEventListener("click", async () => {
    try {
      rootDirectoryHandle = await window.showDirectoryPicker();
      if (!rootDirectoryHandle) return;

      statusMsg.textContent = "Folder: " + rootDirectoryHandle.name;
      folderTreeContainer.innerHTML = "";
      document.getElementById("editorTitle").textContent = "No file selected";
      document.getElementById("editorContent").innerHTML = "";
      editableFilesMap.clear();
      currentFileHandle = null;

      const structure = await buildFolderStructure(rootDirectoryHandle);
      if (!structure) {
        folderTreeContainer.innerHTML = "<p>No .weapon/.upgrades files found.</p>";
        resetAllBtn.classList.add("hidden");
        return;
      }
      originalStructure = structure;
      folderStructure = structure;
      renderFolderTree(folderStructure, folderTreeContainer);
      resetAllBtn.classList.remove("hidden");
    } catch (err) {
      console.error("Folder selection error:", err);
      statusMsg.textContent = "Failed to access folder.";
    }
  });

  resetAllBtn.addEventListener("click", async () => {
    const sure = confirm("Reset ALL editable files to default values on disk?");
    if (sure) {
      await resetAllToDefault();
    }
  });

  searchInput.addEventListener("input", (e) => {
    onSearchChange(e.target.value);
  });
});
</script>
</body>
</html>
